# JavaScript概述

## 1.JavaScript 简介
- 网景Netscape开发了JavaScript(注册商标), ECMA制定了JavaScript语言的标准ECMAScript
- 兼容性: 浏览器在发布时就确定了JavaScript的版本

## 2.JS作用
- 验证表单(早期网速慢)
- 页面特效(PC端网页效果)
- 移动端(移动Web和App)
- 异步和服务器交互(AJAX)
- 服务端开发(nodejs)

## 3.JS语言类型
- JS是一种动态类型(弱类型)的**脚本语言**
- 脚本语言是一种解释性语言, 逐行解析执行(相对于编译性语言编译后整体执行)

## 4.JS组成
> JS = ECMAScript + DOM + BOM + 高级
- ECMAScript: JavaScript的语法规范
- DOM(Document Object Model): 操作网页上元素的API
- BOM(Browser Object Model):操作浏览器部分功能的API

## 5.JS使用及注意事项
1. 内嵌: 使用 `<script>` 标签在 HTML 中插入
    - 一般放在body的最后(防止JS找不到元素报错)
2. 外链: 在 `<script>` 中通过 `src=""` 引入
- 用src后`<script></script>`内部的代码会被忽略
- 可使用多对`<script></script>`
- 一对script内若出现错误代码则之后的代码不会执行
- script的属性`type="text/javascript"`(标准写法),` language="JavaScript"`都可省略, 因为html开头写了遵循h5标准


## 6.JS基本代码

1. 输出语句
```javascript
console.log("内容");    // 在控制台打印输出内容
alert("内容");          // 弹窗显示内容
document.write("内容"); // 在页面书写内容(其内容可以识别标签)
```

2. 交互语句
```js
alert("内容");      // 弹出对话框(确定)
prompt("提示信息"); // 弹出对话框(输入内容)
confirm("判断");    // 弹出对话框(是否按钮)
```

# JS变量

## 1.声明变量 let aVariable = "UserName"

> 变量 是数据的“命名存储”。

1. 可以在一行中声明多个变量

2. 一个变量应该只被声明一次 (重复声明报错)

## 2.命名规则

1. 变量名称只能包含 `字母`, `数字`, `$`, `_` (不允许空格)

2. 变量名称首字符不能使用数字

2. 变量名称不能用保留的关键字与符号

3. 变量名称区分大小写

4. 驼峰命名法（camelCase）

6. use strict 下, 赋值前必须先声明



# 数据类型

> *JavaScript 有 8 种基本的数据类型 (7 种原始类型 `Number、String、Boolean、Null、undefined、symbol、bigInt`, 1 种引用类型 [`object`](##object) )*
> JS 属于 "动态类型"(dynamically typed) 编程语言: 定义的变量并不会在定义后被限制为某一数据类型

## 1.Number

### 1.进制
```js
let num = 10;   // 十进制
let num = 012;  // 八进制以 0 开头
let num = 0xA;  // 十六进制以 0x 开头
```

### 2.数值范围

1. Number 类型是一个[二进制格式值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number)不区别整数与浮点数, 都是浮点数, 采用IEEE 754标准的64位双精度格式
2. 只有在 -2^53 + 1 到 2^53 - 1 范围内的整数才能在不丢失精度的情况下被表示(准确比较大小)
```js
/*Number 的几个静态属性 */

Number.MIN_SAFE_INTEGER === -9007199254740991
// [常量]最大的安全整数 -(2^53-1)
Number.MAX_SAFE_INTEGER === 9007199254740991
// [常量]最小的安全整数 (2^53-1)

Number.MIN_VALUE === 5e-324
// 最接近 0 的正值, MIN_VALUE 的值约为 5e-324
// 小于 MIN_VALUE ("underflow values") 的值将会转换为 0
Number.MAX_VALUE === 1.7976931348623157e+308
// MAX_VALUE 属性值接近于 1.79E+308
// 大于 MAX_VALUE 的值代表 "Infinity"

Number.NEGATIVE_INFINITY === -Infinity
// 与全局属性 Infinity 的负值相等, 表示负数无穷大
Number.POSITIVE_INFINITY === Infinity
// 与全局属性 Infinity 的值相等, 表示正无穷大
```

### 3.不要用小数去验证小数

```js
let num1 = 0.1;
let num2 = 0.2;
console.log(num1+num2); // 0.30000000000000004
console.log(0.07*100); // 7.000000000000001
```
原因: 一个能准确表示的十进制小数在二进制下会是循环小数
column0 | column1
------- | -------
十进制 | 二进制
0.1 | 0.0001100110011001100110011001100110011001100110011001101…
0.2 | 0.001100110011001100110011001100110011001100110011001101…
0.3 | 0.0100110011001100110011001100110011001100110011001101…
0.4 | 0.01100110011001100110011001100110011001100110011001101…
0.5 | 0.1
 
### 4.NaN (Not a Number)

- NaN 代表一个计算错误
- NaN 与任何值都不相等, 包括NaN自身 `NaN !== NaN`
- 任何对 `NaN`/`undefined` 的进一步数学运算都会返回 NaN
  - 唯一的例外: `NaN**0 === undefined**0` `=== 1`
- JS 中数学运算是安全的(最坏的情况下会得到NaN): 可以除以0, 将非数字字符串视为数字等, 脚本永远不会因一个致命的错误而停止


### 5.BigInt 类型 (任意整数)
- BigInt 可以表示任意大的整数
    - number 类型无法表示大于 (2^53-1) 或小于 -(2^53-1) 的整数
- 通过在整数字面量后面加 n 的方式定义一个 BigInt `114514n`

## 2.String

1. String必须被括在引号里
    - `'单引号'` `"双引号"`都是"简单"引用
    - <code> &#768; 反引号 &#768; </code>是 功能扩展 引号
2. 获取字符串的长度使用 变量名.length
3. JS 没有 character 类型
4. string是常量, 不可改变(变量重新赋值只改变了地址以指向新string)

4. 多个string可以用`+`拼接
5. string和number类型进行 减 乘 除 运算时, string会转成数字, 转换失败返回NaN

## 3.Boolean

Boolean类型只有`true` `false`两个字面量, 但所有类型均有与这两个 Boolean 值等价的值
`Boolean()`为`ture`的值: true、除0数字、"非空string"、Object(任何对象)
`Boolean()`为`false`的值: false、0 、""、undefined 、null、NaN

## 4.underfined null

`Boolean(underfined|null) == false`

null 仅仅是一个代表"无","空"或"值未知"的特殊值

任何对 `NaN`/`undefined` 的进一步数学运算都会返回 `NaN` (唯一例外:`**0=== 1`)
任何值和`null`运算, 可将null视为`0`(唯一例外:与字符串+操作,此时会转成`"null"`)

## 数据类型转换

### 1.转为String

1. `变量 + ""` 或 `变量 + "其他变量"`
2. `String(变量)`
3. `变量.toString();` // 例外:undefined/null无对应属性

### 2.转为Number

- 算术函数和表达式中会自动进行 `number` 类型转换
    - **`undefined` -> `NaN`**
    - `null / ""` -> `0`
    - `true/false` -> `1/0`
    

1. 变量 `-` `*` `/` 一个数字
2. `Number(变量);`
    - 若变量不是有效数字
    - `string` -> `去除首尾空格后的数字` / `NaN`

3. `parseInt()` `parseFloat()` 取整/取浮点数
    - 从首位开始取数字
    - "" -> NaN
    - 首字符为字母 -> NaN

### 3.转为Boolean

- 发生在逻辑运算中
- 也可显式地调用 `Boolean(value)` 进行转换
- 直观上为“空”的值（ 如 `0`, `""`, `null`, `undefined`, `NaN`）将变为 `false`
- 其他值 ( 如 **`"0"`, `" "`**, 任何Object ) 变成 `true` ( JS 中，非空的字符串总是 `true` )

### 4.进制转换

十进制转换成n进制: `.toString(n);`
n进制转换成十进制: `parseInt( ,n)`



# 函数

## 函数定义

### 函数声明

- 方式1. 声明式函数
    - 最强大, 定义完毕后使用无位置限制
    - 不可销毁
    ```javascript
    function fn1(){
        console.log("我是第一种定义方法！");
    } //在代码块{...}后以及有代码块的语法结构（例如循环）后不需要加分号;
    ```

- 方式2. 赋值式函数
    - 必须在定义函数之后才能使用函数
    - 函数的销毁使用 `fn2 = null;`
    ```javascript
    let fn2 = function (){
        console.log("我是第二种定义方法！");
    };  // 注意分号
    ```

- 方式3. 构造函数
    - 必须在定义函数之后才能使用函数
    - 非常强大, 执行的函数代码以字符串的形式传入, 就可以从地址栏/后台传入
    ```javascript
    let fn3 = new Function("a", "b", "console.log(a+b + '我是第三种定义方法！')");
    ```

### 函数调用

1. 函数名调用: `函数名();`
    ```javascript
    foo();
    ```

2. 函数自调用 `(function(){})();`
    - 函数的自调用仅执行一次
    - 函数的参数带入通过后面的小括号带入数据
    - 里面的内容是私有的变量或者函数, 形成了封闭空间
    ```javascript
    (function (a,b){
        console.log("我是第二种定义方法！" + a+b); // 我是第二种定义方法！3
    })(1,2);  // 后面的额小括号用来传入参数
    ```

3. 使用`.call()` `.apply()`
    ```javascript
    foo.call(null,参数1，参数2, ...);
    foo.apply(null,[参数1，参数2, ...]);
    ```


### 函数内容

1. 函数名
    - 禁止同名(同名函数重新定义会覆盖前面的内容)
    - 驼峰命名法camelCase

2. 参数

- 形参不需要写 let 
- 形参的个数和实参的个数可以不一致(不使用/为`undefined`)

2. 函数内容与函数体
    ```js
    //打印函数名就等于打印整个函数
    console.log(fn);
    //打印执行函数就等于打印函数的返回值
    console.log(fn()); 
    ```

### 函数也是对象

**所有的函数都是由 Function 构造函数创建的实例对象**
 Function是对象也是函数。然后查看它的 `__proto__` 指向的是 Object的原型对象。所有的对象指向的都是Object的原型对象
只要有 `__proto__` 的就是对象；

只有要 `prototype` 的就是函数，因为函数才会调用 prototype 属性。  

对象不一定是函数: 比如 Math，中有 `__proto__` ，但是没有 `prototype`

函数.length === 函数形参的个数

arguments.length === 函数实参的个数

arguments.callee === 在哪个函数里面就表示哪个函数（当前调用其的函数）



### 返回值

> 默认返回`undefined`, 如在无显式使用return语句或return后无内容时
**return 可以返回的类型包含下列几种: **

1. 工厂模式
    0. 工厂模式:就是将要实现某个功能所要具有的方法和属性封装在一个函数当中,在需要的时候进行实例化或者调用.
    - 函数内部创建一个对象，由一个局部变量接收，然后返回这个对象。
    - 可以通过函数参数改变对象的内容

2. 单例模式
    - 在开发当中,是将一个项目进行分组编写代码的模式,把描述同一个事物或者对象的属性和方法放在一个封装好的函数(内存空间)当中.

3、通过参数传入对象
4、通过参数传入函数
5、返回一个私密对象
6、返回多个元素的数组（ES5中的解构赋值）
7、返回多个元素的对象（ES6中解构赋值）
8、传入参数为函数，返回对象
9、返回函数

## 变量与作用域

1. 全局变量

    1. 在 script 使用 var 定义的变量(所有的 script 共享其全局性，js 里面没有块级作用域概念，只有全局作用域和局部作用域)
    2. **隐式全局变量**: 在 script 没有 var 的变量
    3. 使用window全局对象来声明，全局对象的属性对应也是全局变量
    - 全局变量不能被删除
    - 隐式全局变量可被删除

2. 局部变量

    1. 函数内部声明的变量
    2. 函数的形参
        - 若函数内部声明了同名变量，则 优先使用 内部变量

3. 预解析
    1. **变量声明提升**: JavaScript引擎在执行的时候,会将变量的声明提升到当前作用域的最前面，但变量的赋值不会提升，此时变量的值为undefined

    4. **函数提升**: 会将函数的声明提升到当前作用域的最前面，但不会调用

    5. **let的提升**: let、const声明的变量实际上也会有变量提升，只是它们暂时不能被访问，也就是暂时性死区(此时访问会报错)

    - 多对的 script 标签中函数重名的话，预解析不会冲突。也就是预解析的作用域是每一个的 script 标签
    - var先提升，function再提升: 

### 严格模式

window.func(); // 严格模式下必须加 window，因为他认为函数是一个方法，方法必须通过对象来调用的。

## 常用函数

1. 匿名函数
    1. 直接调用
    2. 绑定事件
    3. 定时器
2. Math函数
```js
Math.random()   //0~1之间随机数

Math.abs(x)     //绝对值
Math.pow(10,2)  //10的2次方

Math.round(x)   //四舍五入取整
Math.ceil(x)    //向上舍入
Math.floor(x)   //向下舍入
```
3. 生成随机数

let minNum = 1;
let maxNum = 100;
let num = Math.round(Math.random() * (maxNum - minNum)) + minNum;

`.toFixed(n)` 方法可把 数字四舍五入为指定小数n位数的数字。


# 数组

## 声明数组

1. 通过字面量定义数组
    - `let arr = [];` 
        - 可以在方括号中添加初始元素
        - 以逗号分隔元素
2. 少用: 通过构造函数定义数组
    - let arr = new Array(); 
    - 使用数字调用会创建指定长度的全`undefined`数组
    - 多个参数为数组元素, 无参数时可省略括号

## 数组内部

- 数组可以存储**任何**类型的元素(包括数组)
- 数组 Array 是一种特殊的 **对象 Object**
    - `Arr[n]` 与 `obj[key]` 相同
    - 数组 Array 通过**引用**来复制
- 判断数组
    1. `Array.isArray(value)` 判断 `value` 是否为数组
    2. `A instanceof B`
        - 是一个关键字，判断A是否是B类型
        - `[] instanceof Array //ture`
    - `typeof [] === 'object'`
- 不按照 **'有序集合'** 使用数组会取消针对数组的优化
    - 如添加一个非数字的属性, 存在空缺/不连续值, 以倒序填充数组

6. 数组循环

    1. `for`循环: arr[0] ~ arr[arr.length-1]
    2. `for..of` 只能获取元素值, 无索引
    3. 不应使用 for..in (无对应优化速度慢10-100倍!)

10. 不要使用 `==` 比较数组

    - `==` 不会对数组进行特殊处理(处理参考Object)

8. 多维数组 Multidimensional arrays 储存矩阵 matrix



## 数组方法

### 添加/移除数组元素

1. 数组长度: `数组名.length; `
    - length属性的值是数组中元素的总个数
    - 数组的 `length` 属性值为`最大的数字索引值+1`
    - 手动增加 `length` 增加 `undefined` 项
    - 手动减小 `length` 截断数组
    - 清空数组 arr.length = 0;(推荐`arr=[];`)

4. `pop`/`push`, `shift`/`unshift` 方法
    - 队列 queue 是最常见的使用数组的方法之一
    - JS 中的 Array 属于 双端队列 deque, 既可用作队列也可用作栈(允许从首/末端来添加/删除元素)
        1. 队列queue: FIFO (First-In-First-Out), 可使用 push shift
        2. 栈stack: LIFO (Last-In-First-Out), 可使用 push pop
    - 作用于数组末端的方法 (运行快速)
        1. `arr.pop()` 取出并返回数组的最后一个元素
        2. `arr.push()` 在数组末端添加(一个或*多个*)元素
    - 作用于数组首端的方法 (运行缓慢)
        1. arr.shift() 取出并返回数组的第一个元素
        2. arr.unshift() 在数组开头添加(一个或*多个*)元素


0. **`arr.splice(start[, deleteCount, elem1, ..., elemN])`**

    - 从索引 `start` 开始修改 `arr`
        1. 删除 `deleteCount` 个元素
        2. 在当前位置插入 `elem1, ..., elemN`
        3. 返回**被删除**的元素所组成的数组。
    - `deleteCount = 0` 时插入元素
    - 支持 *负向* 索引

1. `arr.slice([start], [end])`

    - 返回新**数组**, 由索引 `start` 到但*不包括* `end` 的数组项构成
    - 不带参数 `arr.slice()` 创建 `arr` 的*副本*
    - 支持 *负向* 索引

2. `arr.concat(arg1, arg2...argN)`

    - 返回一个包含来自于 `arr` 然后是 `arg1`, `arg2` 的元素的新数组
    - 若 `argN` 非数组则复制 `argN`**其自身**
        - 例外: 若类数组对象具有 `Symbol.isConcatSpreadable` 属性则当作数组来处理

### 迭代方法(转换/排序 数组)

0. 遍历运行 `forEach`
    - 为数组的每个元素都运行一个函数
    - 该函数的结果(如有返回)会被抛弃和忽略
    ``` javascript {.line-numbers}
    arr.forEach(function(item, index, array) {
        // ... do something with item
        //箭头函数简化 (参数) => { 函数体 }
    });
    ```

- 遍历运行 `map`
    - 最有效最常用
    - 对数组的每个元素都调用函数并返回 结果数组
    ``` javascript {.line-numbers}
    let result = arr.map(function(item, index, array) {
     // 返回新值而不是当前元素
     // eg. arr.map(item => item.length);
    })
    ```

- `reduce` / `reduceRight`

    ``` javascript {.line-numbers}
    let value = arr.reduce(function(accumulator, item, index, array) {
        //eg. arr.reduce((sum, current) => sum + current, 0);
    }, [initial]);
    ```
    1. 对数组的每个元素都调用函数
    2. 其结果作为 `accumulator` 传递给下个函数
    3. 返回最后的结果
    - 第一次调用 `accumulator` 等于 `initial`
        - 若未提供 `initial` 则将首个元素作为初始值并从第二个元素开始迭代
        - 若未提供 `initial` 且数组为空则*报错*
    - `arr.reduceRight()` 除顺序从右到左外与 `arr.reduce()` 相同 

- `sort(fn)`
    - 遍历 并对数组进行 **原位 in-place** 排序 (通常忽略返回的原数组)
    - 若无参数 `fn` 则元素默认被按 _字符串_ 进行排序
    - 提供 排序函数 `fn()` 用于比较
        - 需要返回 正数 表示 大于 , 负数 表示 小于 
        - `arr.sort( (a, b) => a - b );`
    - 使用 `localeCompare` 比较特殊字符 *for strings*

- `arr.reverse();` 颠倒并返回颠倒后的数组 `arr`

- `split` `join`

    - `str.split(delim)` 
        - 通过分隔符 `delim` 将字符串分割成一个数组
        - 提供空字符串 `''` 将`str`拆分为 单字符 数组
        - 不常用: 提供第二个数字参数限制数组长度(忽略剩余字符)
    - `arr.join(glue)`
        - 使用 `glue` 将数组粘合成字符串
        - 传入 `undefined` 时效果与 `String(arr)` 相同 (以分号`;`分隔)

- 数组 `toString` 方法

    1. `String(arr)` 返回以逗号隔开的元素列表
    0. 数组没有 Symbol.toPrimitive 也没有 valueOf , 只能执行 toString 进行转换


### 在数组中搜索

- 从索引 `from` 开始搜索 `item`
    - `arr.indexOf (item, from)` 返回 `索引` | `-1`
    - `arr.includes(item, from)` 返回 `true` | `false`
    - `arr.lastIndexOf(item, from)` 除顺序从右到左外与 `arr.indexOf()` 相同 
    注意
    1. 一般只传入参数 `item` 从头开始搜索
    1. `indexOf` `includes` 都使用严格相等 `===` 进行比较
    2. `includes` 可以正确处理 `NaN` (`indexOf`查找不到)

- 寻找首个特定对象 (依次对数组中的每个元素调用函数)

    ``` javascript {.line-numbers}
    let result = arr.find(function(item, index, array) {
        // 如果返回 true，则返回 item 并停止迭代
        // 对于假值 (falsy) 的情况，则返回 undefined
    });
    ```
    - `arr.find()` 若函数返回 `true` 则返回 `item`, 否则返回 `undefined`
    - `arr.findIndex()` 返回找到元素的`索引值`, 否则返回 `-1`
    - `arr.findLastIndex()` 除顺序从右到左外与 `arr.find()` 相同 

- 寻找所有匹配对象(过滤数组)

    ``` javascript {.line-numbers}
    let results = arr.filter(function(item, index, array) {
        // 返回包含所有匹配元素的新数组
        // 若无匹配则返回空数组''
    });
    ```

3. 新: `arr.at(i)` 获取最后一个元素(`i`取`-1`)
    - 若 i >= 0 则与 `arr[i]` 等同
    - 若 i 为负 则从数组的尾部向前数
        - `arr[i]` 中 `i` 不能为负, 否则返回 `undefined`


### 方法补充: `thisArg`

- 几乎所有调用函数的数组方法都接受一个 可选的附加参数 `thisArg`
    - 如 `find`, `filter`, `map`, 除了 *sort* 是一个特例

- `thisArg` 参数的值在 `func` 中变为 `this`

    ``` javascript {.line-numbers}
    arr.find(func, thisArg);
    arr.filter(func, thisArg);
    arr.map(func, thisArg);
    // ...
    // thisArg 是可选的最后一个参数
    ```

- 常用: 可使用 *箭头函数* 替换便于理解

- 其他方法

arr.some(fn)/arr.every(fn) 检查数组 —— 与 map 类似，对数组的每个元素调用函数 fn。如果任何/所有结果为 true，则返回 true，否则返回 false。

arr.fill(value, start, end) —— 从索引 start 到 end，用重复的 value 填充数组。


4. arguements
    - 只在函数中使用，代表传入实参的数组。
    - **arguements是一个类数组对象, 可修改元素,但不能改变长短(无push...方法)**
    - 在调用函数时，除了this，浏览器每次还会传递进一个隐含的参数: 封装实参的对象arguements
    - 在调用函数时，我们所传递的实参都会在arguements中保存
    - arguments.callee相当于函数名, 对应当前正在执行的函数对象


## 字符串

### Quotes 引号

1. 字符串可以包含在 '单引号' , "双引号" , &#96;反引号&#96; 中
2. &#96;反引号&#96;
    - 反引号允许通过 `${…}` 将 _任何表达式_ 嵌入到字符串中
    - 反引号允许字符串**跨行**
    - 使用换行符 (newline character) `\n` 与 `反引号和普通换行` 创建的字符串相等(==)
3. 特殊字符/转义字符
    - 特殊字符都以反斜杠字符 `\` (backslash) 开始
    - `\'` , `\"` , `\n` , `\t` , 

### 字符串属性、方法

1. `str.length` 表示字符串长度
    ``` javascript {line-numbers}
    `\n`.length === 1; //ture, \n 是一个单独的特殊字符
    ```
2. 访问/遍历字符
    - `str[0]` 如果未找到字符则返回 `undefined`
    - `str.charAt(1)` 未找到则返回 `''` (空字符串)
        - `str.charCodeAt(index);` 获取字符串中下标为 index 的字符的 ASCII 编码
        - `String.fromCharCode(num1, ..., numN)`返回一个ASCII编码为num1,...numN对应的字符组成的字符串

    - 遍历字符串 `for..of`
    ``` javascript {.line-numbers}
    for (let char of "Hello") {
    alert(char); // H,e,l,l,o(char 变为 "H", 然后是 "e"...)
    }
    ```
3. 字符串创建后不可修改只可替换
    `TypeError: Cannot assign to read only property '0' of string 'Hi'`

4. 改变大小写
    - `str1.toLowerCase()`
    - `str2[0].toUpperCase() `

5. 查找子字符串
    
    1. `str.indexOf(substr, pos)` 
        - 从给定位置 `pos` 开始在 `str` 中查找 `substr`
        - 成功则返回匹配的位置
        - 若未找到则返回 `-1`
            - 在 `if` 中使用应检查 `-1`
        - `str.lastIndexOf(searchValue[, fromIndex])` 反向查找
        - 旧: bitwise NOT `~` 运算符 简写indexOf 检查
            - 对于 32-bit 整数，`~n === -(n+1)`

    2. `str.includes(substr, pos)` 
        - 根据 `str` 中是否包含 `substr` 来返回 `true/false`
    3. `str.startsWith()` 返回 `true/false`
    4. `str.endsWith()` 返回 `true/false`

5. 正则表达式

    1. `str.search(substr|regexp)`
        查找满足字符串substr或者正则表达式regexp的str中第一次出现的索引，Eugene没找到返回-1.
        PS: 如果传入一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象。

    2.  `str.match(regexp);`
        返回一个根据正则表达式regexp查找str的所有匹配的字符串，然后将匹配的字符串集合以数组形式返回。
        regexp: 一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 。如果你未提供任何参数，直接使用 match() ，那么你会得到一个包含空字符串的 Array : [""] 。

    3. `str.replace(regexp|substr, newSubStr|function)`
        说明: 返回一个由替换值替换一些或所有匹配的模式后的新字符串。他不会改变原字符串。

        regexp|substr: 将要被替换的字符串或者正则表达式

        newSubStr|function: 新的字符串或者一个用来创建新子字符串的函数。


6. 获取子字符串

    1. **`str.slice(start [, end])`**
        - 返回字符串从 `start` 到(但**不包括**)`end` 的部分
        - 若无第二个参数则运行到字符串末尾
        - `start/end` 可`<0`(为负值)
            - 起始位置从字符串结尾算起
            - 按原顺序返回
        - `start` _不能_ 大于 `end`, 否则返回 `''` (空字符串)


    2. `str.substring(start [, end])`
        - 与 `str.slice` 类似
        - `start/end` _不能_ `<0` (负值被视为 `0`)
        - `start` 可大于 `end`
            - `str.substring(2, 6) === str.substring(6, 2)`

    3. `str.substr(start [, length])
        - 返回字符串从 `start` 开始的给定 `length` 的部分
        - `start` 可为负数
            - 起始位置从字符串结尾算起
            - 按原顺序返回

7. 比较字符串

    0. `str.codePointAt(pos)` 与 `String.fromCodePoint(code)`
        1. 返回在 `pos` 位置的ASCII码
        2. 通过十进制 ASCII码 `code` 创建字符
    ``` text {line-numbers}
        字符:    0   1...8  9 ... A   B...Y  Z ... a   b...y  z
        ASCII码: 48  ....   57 .. 65  ....   90 .. 97  ....   122
    ```
    1. 调用 `str.localeCompare(str2)` 会根据语言规则返回一个整数
        - 若 `str` 在前则为负, 若 `str2` 在前则为正, 相同则为 `0` 
        - 比较按照国际化标准 ECMA-402 

8. 其他方法

    1. `str.trim()` 删除字符串前后的空格 (trims)
    2. `str.repeat(n)` 重复字符串 `n` 次



## 日期和时间

### 创建 Date

- `new Date()` 
    - 不带参数则时间等于创建时的当前日期和时间

- `new Date(milliseconds)`
    - 传入 num 则时间等于 1970.1.1 UTC+0 后经过的毫秒数
    - 该整数参数被称为 时间戳 timestamp

- `new Date(datestring)`
    - 传入字符串则被自动解析
    - 算法与 `Date.parse()` 相同

- `new Date(year, month[, date, hours, minutes, seconds, ms])`
    - 只有 年 月 必须
    - `year` 应该使用四位数 (不推荐 二位数视为19XX)
    - `mouth` 从 `0` ~ `11` 代表 一月 ~ 十二月
    - `date` 默认为 `1` 指当月的具体某天
    - `hours/minutes/seconds/ms` 默认为 `0` 
    - 时间最大精确到 1毫秒


### 访问 Date

- `dateObj.getFullYear()`
    - 只使用标准化方法`getFullYear()`
    - 返回 4位数 年份

- `dateObj.getMonth()`
    - 返回 (一月) `0` ~ `11` (十二月) 月份

- `dateObj.getDate()`
    - 返回当月的 `1` ~ `31` 具体日期 

- `dateObj.getDay()`
    - 返回一周中的第 (周日) `0` ~ `6` (周六) 天

- `dateObj.getHours(), getMinutes(), getSeconds(), getMilliseconds()`

- 以上方法的结果都基于**当地时区**
    - 可使用 `dateObj.getUTCFullYear(), getUTCMonth(), getUTCDay()` 获取基于 UTC+0 时区的年月日
`
- 特殊方法 (无UTC变体)

    - `dateObj.getTime()`
        - 返回日期的时间戳, 即从 1970-1-1 00:00:00 UTC+0 开始经过的毫秒数

    - `dateObj.getTimezoneOffset()`
        - 返回 UTC 与本地时区的时间差, 单位分钟
        - UTC+8 地区结果为 480 (8 * 60)

### 设置 Date

- `dateObj.setFullYear(year, [month], [date])`

- `dateObj.setMonth(month, [date])`

- `dateObj.setDate(date)`

- `dateObj.setHours(hour, [min], [sec], [ms])`

- `dateObj.setMinutes(min, [sec], [ms])`

- `dateObj.setSeconds(sec, [ms])`

- `dateObj.setMilliseconds(ms)`

- `dateObj.setTime(milliseconds)` (使用自 1970-01-01 00:00:00 UTC+0 以来的毫秒数来设置整个日期)

- 除 `setTime()` 都有 UTC 变体 如 `setUTCHours()`

- **自动较准 Autocorrection**

    - 可以设置超范围的数值, 零, 负值
    - `.setDate(0)` 代表上个月最后一天


### 转换 Date

- 将 Date 对象转化为数字时得到 对应的时间戳, 与 `date.getTime()` 效果一样

- Date 可相减 得到 毫秒为单位的时间差

### **`Date.now()`** 

- 推荐使用 `Date.now()` 测量时间间隔
- `Date.now()` 返回当前的时间戳, 与 new Date().getTime() 作用相同
- 且 `Date.now()` 不创建 Date 对象, 速度更快且不用回收内存

### 基准测试 Benchmarking

    1. 用时间差来衡量不同函数
    2. 整个度量测试包应该多次运行, 且被测函数应该交替运行
    3. 增加预热步骤 (JS 优化只针对多次执行的"hot code"有效)

### `Date.parse(str)` 解析字符串

- 使用 `Date.parse(str)` 解析指定格式的字符串
    - 返回 时间戳timestamp (自 1970-01-01 00:00:00 起所经过的毫秒数)
    - 格式不正确则返回 **`NaN`**
- 字符串格式为 `YYYY-MM-DDTHH:mm:ss.sssZ`
    - `T` 为分隔符
    - `Z` 为 `+-hh:mm` 格式的时区 (单个字符 `'z'` 代表 UTC+0 时区)
    - 可省略至年份 `'YYYY'`
- 可通过返回的时间戳直接创建 `new Date` 对象
    - ``` javascript {line-numbers}
      let date = new Date( Date.parse('2022-10-30T12:34:56.789+10:00') );
      ```




# Object 基础知识

## Object / plain object

> [JS 有八种数据类型](##数据类型)

- 7 种原始类型: 值只包含一种 (字符串, 数字 ...)

- 1 种引用类型: 用来存储键值对和更复杂的实体

-  `literal` 字面量
    - Literals represent values in JavaScript. These are **fixed values**—not variables—that you literally provide in your script.
    - `literal` 字面量是用于表达一个固定值的表示法 (或用来为变量赋值时的常数量), 又叫常量
    - 字面量分为 字符串/数组/对象/函数 字面量( `string/array/object/function` `literal` )等
        - eg. `let str1 = "a str";` `"a str"` 是数字字面量, `str1` 是变量
    - 判断自变量    
        1. 这个量可以作为一个合格的表达式
        2. 执行结果等于其自身

### `Object` 创建
    - 通过使用带有可选 **属性列表** 的花括号 {…} 来创建对象
        ``` javascript {.line-numbers}
        let Object1 = new Object(); //一 “构造函数” 的语法
        let Object2 = {
            [key1:value1, 
            key2:value2, 
            ...]
            }; //二 “object literal 对象字面量” 的语法
        ```
    - 一个属性 `property` 就是一个键值对: ( 属性的`key/name/identifier(键/名字/标识符)` `:` 属性的 `value(值)` )
    - 其中 键 `key` **只能**是 ***`String` / `Symbol`*** 类型 , 值 `value` 可以是任何值
        - 若 `key` 中有空格则需加 `""`, 如 `"a key": ture,` 
    - 列表中的最后一个属性应以**逗号结尾**, 称尾随或悬挂逗号 (trailing/hanging comma)

2. 访问属性值
    - 使用 `.`点符号**访问**属性值(value)  `ObjectName.keyName` 
        - `.`要求`key`是有效的变量标识符: 不含空格&不以数字开头&不含特殊字符(可用`$_`)
    - 使用 `delete`操作符 **删除** 属性值 `delete Object1.key2`
    - 使用方括号 `ObjectName[keyName]` 访问属性值 `value`
        - `[]`中的 `KeyName` 可以是 **任意**表达式 , 比如变量

3. 计算属性
    - 创建对象可在对象字面量中使用方括号 `[ObjectName] : value`
    - 此处 `ObjectName` 可为变量, 表达式

4. 属性值简写
    - 属性名简写方式可以与正常方式混用
    ```javascript {.line-numbers}
    function makeUser(name, age) {
    return {
        name: name, // 1
        name,       // 2, 1 2 等效
        age: age,   //3
        age,        //4 , 3 4 等效
        // ……其他的属性
    };
    }
    let user = makeUser("John", 30);
    alert(user.name); // John
    ```

5. 属性名称限制
    - 属性命名**无限制**, 属性名可以是任何字符串或者 symbol
    - 其他类型会被自动地转换为字符串 (如 `0` -> `"0"`)
    - 例外: 名为 `__proto__` 的属性, 不能将它设置为一个非对象的值

6. 属性存在性测试, `"in"` 操作符
    - JS 的 Object 能够被访问**任何**属性, 若不存在则返回 `undefined`
    - `"ObjectKey1"` `in` `ObjectName` 检查属性是否*存在*
        - `in` 左边的 `属性名` 省略引号则表示一个变量
    - 少用: 若属性值为`undefined`, `in` 判断为 `ture`, 直接访问显示`undefined`

7. `"for…in"` 循环
    - 所有的 `"for"` 结构体都允许在循环中**定义变量**
        - 如 `let key in user`, `let prop in obj`
    - ``` javascript {.line-numbers}
        for ( [let] key in obj) {
        alert( key );
        alert( user[key] );
        } 
        ```

8. 遍历时的顺序
    - 规范中 ownPropertyKeys 方法定义了一个对象的遍历顺序
        1. 先将 整数属性 按 升序 排列。
        2. 再将 字符串属性 按 定义顺序 排列。
        3. 最后将 Symbol 符号属性 按 定义顺序 排列。
    - **整数属性** 指可在不做任何更改下与 *整数* 相互转换的*字符串*
        - `+0 <= parseFloat(key) < 2^32 - 1` (最大安全整数)
        - eg. `"+49" -> 49 -> "49" != "+49"`
            - `"1.2" -> 1  -> "1" != "1.2"`


## Object 引用和复制

- 赋值了对象的变量存储该对象**在内存中的地址**, 而非对象本身
    - 字符串, 布尔值等原始类型始终以"整体值"的形式被复制
    - 相比对象的根本区别之一是其"通过引用"被存储和复制的
- 使用 `const` 声明的对象**可被修改**
    - 引用对象的地址不可改(将对象作为整体), 对象的属性可以改
<br />

- 比较对象
    - 仅当两个对象为同一对象时两者才相等
    - 两个独立的对象不相等, 即使都为`{}`
    -   ``` javascript {.line-numbers}
        let a = {};
        let b = a;
        let c = {};
        alert ( a === b ); // ture
        alert ( a !== c ); // ture
        ```
- 克隆与合并, **浅拷贝** `Object.assign`
    - ``` javascript {.line-numbers}
        for(let key in user) clone[key] = user[key];
        
        Object.assign(dest, [src1, src2, src3...]) //返回dest
        ```
    - `Object.assign(目标对象, [源对象1, 源对象2...])`
        - 结果返回目标对象
        - 目标对象的相同属性会被源对象覆盖
        - 可用来合并多个对象

- 深层克隆 **深拷贝** 
    - 若对象的属性引用了其他对象, 浅拷贝不完全
    - 递归实现, 如 `lodash` 库的 `_.cloneDeep(obj)`

## 垃圾回收

- 垃圾回收是自动完成的, 不能强制/阻止执行
- Reachability 可达性
0. 当对象是可达状态时一定存在于内存中
1. 固有可达值(roots)不能被释放
    - 如: 当前执行的和嵌套调用链上的函数及其局部变量和参数, 全局变量, 等
2. 若值可通过引用/引用链从根访问任何其他值, 认为该值是可达的
    - 对外引用不重要, 只有**传入引用**才可以使对象可达(指向该对象)
    - 无**外部引用**的孤立对象(群)也视为不可达


## Object 方法, `"this"`

> 参考[You-Dont-Know-JS/this & object prototypes](https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN/this%20%26%20object%20prototypes)

- 作为对象属性的 函数 被称为 ***`method`*** (方法)
    - 方法简写 (首选较短的语法)
       ``` javascript {.line-numbers}
        user = {
        sayHi: function() { alert("Hello"); }
        };

        // 方法简写
        let user = {
        sayHi() { alert("Hello"); } // 与 "sayHi: function(){...}" 一样
        };
        ```

- 方法中的 `"this"`
    - `user.func1()`
    - `this` 的值就是点之前的这个对象`user`, 即调用该方法的对象
    <br />

- `this` 不受限制
    - JS 中的 `this` 可以用于任何函数, 即使它不是对象的方法
    - `this` 的值在代码运行时计算出来, 取决于代码上下文
    <br />

- 没有对象的情况下调用含有 this 的函数
    - ***`"use strict"`, `this == undefined`***
    - 非严格模式的情况下, `this` 将会是 全局对象
    <br />

- 箭头函数**没有**自己的 `"this"`
    - 若箭头函数中引用 `this`, 则其值取决于外部 "正常的" 函数

## 构造器和操作符 "new"

1. 构造函数
    - 构造函数在技术上是常规函数
    1. 约定: 命名以大写字母开头
    2. **只能**由 `"new"` 操作符来执行
    <br />

2. 当函数用 `new` 操作符执行时
    1. ***`this = {};`*** (隐式创建) 
    2. 函数体执行: 通常修改 `this`, 添加新的属性等
    3. **`return this;`** (隐式返回) 
    - 立即&单次调用`new function()`
        - 创建单个复杂对象
        `let obj = new function() { ... }`
    <br />

3. (少用) 构造器模式测试: `new.target`
    - 检查函数是否被使用 `new` 进行调用
    <br />

4. 构造器的 `return`
    - 通常构造器 无 `return` 语句
    1. 若 `return` 返回一个对象, 则返回这个对象
    2. 若 `return` 返回原始类型/无返回, 忽略并返回 `this`
    <br />

5. 构造器中的方法
    - 不仅是属性, 也可将 方法 添加到 `this` 中

## 可选链 `?.`

> `?.` 能够安全地访问嵌套属性

- `?.` 前的变量必须已声明/定义, 否则报错
- 若 `?.` 前的值为 `undefined/null` (不存在), 立即停止并返回`undefined` ("短路效应")
- `?.` 使其**前**的值成为可选值
- 其它变体: `?.()`, `?.[]`, `delete user?.name; //user存在则删除user.name`
- 可使用 `?.` 来安全地读取或删除, 但 **不能写入** (不能用在赋值语句的左侧)


## Symbol 类型

> Object 的属性 key 只能是 `String` / `Symbol` 类型

 
- `"Symbol"` 值表示唯一的标识符
    ``` javascript {.line-numbers}
    let id = Symbol(["描述/Symbol名"]);// id 是 symbol 的一个实例化对象, 是描述为 "描述 / Symbol名" 的 Symbol
    ```
- `Symbol` 保证是 **唯一** 的
    - 描述完全相同的Symbol的值也是不同
    - 描述只是一个标签, 无任何影响

- `Symbol` 不会被自动转换为字符串
    ``` javascript {.line-numbers}
    let id = Symbol("id");
    alert(id); // TypeError: Cannot convert a Symbol value to a string
    alert(id.toString()); // Symbol(id), 现在它有效了
    alert(id.description); // id, 只显示 description/描述
    ```



## Object — 原始值转换

> 所有对象在布尔上下文中均为`true`

- JavaScript 运算符处理对象的方式不允许自定义
- 数学运算下对象会被自动转换为原始值进行运算并得到一个原始值

## 属性标志和属性描述符

### 属性标志

对象属性（properties），除 `value` 外，还有三个特殊的特性（attributes），也就是所谓的“标志”：

- `    writable` — 如果为 `true`，则值可以被修改，否则它是只可读的。
- `  enumerable` — 如果为 `true`，则会被在循环中列出，否则不会被列出。
- `configurable` — 如果为 `true`，则此属性可以被删除，这些特性也可以被修改，否则不可以。

- 以上属性默认为`true`

查询有关属性的 完整 信息: 
```js
let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
```
obj:需要从中获取信息的对象。
propertyName:属性的名称。
返回值是一个所谓的“属性描述符”对象：它包含值和**所有**的标志。


修改标志，我们可以使用:
```js
Object.defineProperty(obj, propertyName, descriptor)
```
obj，propertyName:要应用描述符的对象及其属性。
descriptor:要应用的属性描述符对象。
如果该属性存在，defineProperty 会更新其标志。否则，它会使用给定的值和标志创建属性；在这种情况下，如果没有提供标志，则会假定它是 false。(都未定义则3个都为false)


如果速度很重要，就请不要修改已存在的对象的 `[[Prototype]]`
从技术上来讲，我们可以在任何时候 get/set `[[Prototype]]`。但是通常我们只在创建对象的时候设置它一次，自那之后不再修改：rabbit 继承自 animal，之后不再更改。

并且，JavaScript 引擎对此进行了高度优化。用 `Object.setPrototypeOf` 或 `obj.__proto__`= “即时”更改原型是一个非常缓慢的操作，因为它破坏了对象属性访问操作的内部优化。因此，除非你知道自己在做什么，或者 JavaScript 的执行速度对你来说完全不重要，否则请避免使用它。






# 正则表达式

正则表达式, regular expression, RegExp是一个描述字符规则的对象
正则表达式常用于表单数据校验

## 定义正则表达式(创建一个 RegExp 对象)

1. 使用`/正则表达式字面量/[attributes]`直接声明
    - 当正则表达式保持不变时，使用此方法可获得更好的性能
    - 可附加字符串属性 "g"、"i" 和 "m"，分别用于指定全局匹配、区分大小写的匹配和多行匹配。
    
1. 调用RegExp对象的构造函数

    ```js
    let reg = new RegExp(pattern, [attributes]);
    ```
    - pattern: 模板字符串
    - attributes:字符串，可选。包含属性 "g"、"i" 和 "m"，分别用于指定全局匹配、区分大小写的匹配和多行匹配。
        - 从 ECMAScript 6 开始，当第一个参数为正则表达式而第二个标志参数存在时，new RegExp(/ab+c/, 'i') 不再抛出 TypeError

## 正则表达式的使用

- 使用正则表达式来测试某个字符串是否符合正则表达式所规定的规则。

- 正则表达式可以被用于RegExp的`exec`和`test`方法以及 String的`match`、`replace`、`search`和`split`方法。

### 1.String方法

`str.match(regexp)`: 返回一个数组或者在未匹配到时返回null。

`str.search(regexp)`:返回匹配到的位置索引，或者在失败时返回-1。

`str.replace(regexp,newstr)`:使用替换字符串替换掉匹配到的子字符串后返回

`str.split(regORstr,num)`: 用正则或字符串分隔一个字符串, 返回分隔后的子字符数组


### 2.RegExp属性

- 一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置
```js
RegExp.prototype.ignoreCase  //返回一个布尔值，表示是否设置了i修饰符。
RegExp.prototype.global      //返回一个布尔值，表示是否设置了g修饰符。
RegExp.prototype.multiline   //返回一个布尔值，表示是否设置了m修饰符。
```
- 另一类是与修饰符无关的属性
```js
RegExp.prototype.lastIndex  //返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义
RegExp.prototype.source     //返回正则表达式的字符串形式（不包括反斜杠），该属性只读。
```

### 3.RegExp方法

`RegExp.prototype.test()`

返回一个布尔值，表示当前模式是否能匹配参数字符串。
语法: `regexObj.test(str)`

`RegExp.prototype.exec()`

描述: 正则实例对象的`exec`方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回`null`。

语法: `regexObj.exec(str)`

参数: str 要匹配正则表达式的字符串。

返回值: 如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的属性。返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组填充到后面。如果匹配失败，exec() 方法返回 null。

如果匹配失败，exec() 方法返回 null，并将正则表达式的 lastIndex 重置为 0。

如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的 lastIndex 属性。完全匹配成功的文本将作为返回数组的第一项，从第二项起，后续每项都对应一个匹配的捕获组。数组还具有以下额外的属性: 

### 特殊字符

`^` 匹配一行的开头
`$` 匹配一行的结尾
`x|y` 匹配x或y

`?` 匹配0次或1次
`*` 匹配0次或多次
`+` 匹配1次或多次
`{n}` 精确匹配n次
`{n,}` 匹配n次及n次以上
`{n,m}` 匹配n次至m次

`\d` `[0-9]` 匹配0-9之间的任一数字
`\D` `[^0-9]` 匹配所有0-9**以外**的字符
`\w` `[A-Za-z0-9_]`匹配任意的字母数字和下划线
`\W` `[^A-Za-z0-9_]`匹配所有字母、数字和下划线**以外**的字符
`\s` `[ \t\r\n\v\f]`匹配空白字符（包括换行、制表、空格符等）
`\S` `[^ \t\r\n\v\f]`匹配非空的字符
`\b` 匹配词的边界
`\B` 匹配非词边界，即在词的内部

### 转义字符（量字符）

`\f`  换页符
`\n`  换行符
`\r`  回车
`\t`  制表符
`\v`  垂直制表符

符号前加 `\` 表示一个直接量
如 `\.`:一个 点 直接量
以及 `*` `+` `?` `/` `|` `\` `(` `)` `[` `]` `{` `}` 直接量

### 括号

1. 方括号[]
JS的正则表达式中的方括号`[]`用来表示一个字符集，表示匹配其中任意一个字符。

方括号中还可以使用连字符`-`表示字符范围
方括号中还可以使用^表示取反，表示匹配除了方括号中指定的字符集以外的任意一个字符

2. 圆括号()
正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容
() 表示将匹配的字符串部分捕获到一个**捕获组**中，可以用于后续的操作


### 常用正则表达式

检查邮政编码//共 6 位数字，第一位不能为 0
检查特定文件名(后缀)
删除多余空格
删除首/尾空格
电子邮件( xxxxx @ xxxx(.xxxx)+)
手机号(1开头任意数字)
身份证
合法日期格式
只能输入中文
账户名只能使用数字字母下划线，且数字不能开头
验证ipv4地址



# DOM

> DOM, Document Object Model, 文档对象模型
DOM是JS操作网页的接口
把 html 文件看成一个文档，因为万物皆对象，所以这个文档也是一个对象。这个文档中所有的标签都可以看成一个对象，比如 div 标签，p 标签等

1. 概念
    - html 页面有一个根标签 html 标签
    - 标签也叫元素，也叫对象
    - 页面中的顶级对象: document

    - 节点(node): 页面中所有内容都是节点, 包括标签,属性,文本等
        - html: 侧重于展示数据
        - xml: 侧重于存储数据

2. DOM树

    - 由文档及文档中的所有元素（标签）组成的树状结构，叫树状图（DOM树）
    - document -> html -> head
                       -> body -> div

3. DOM的作用: 操作页面的元素(标签)
    - 常用操作: 
    - 获取元素 / 动态创建元素
    - 对元素进行操作（设置属性或调用其方法）
    - 事件（什么时机做相应的操作）
        3. 添加事件处理函数（注意: 所有function后面都有分号。）


## 获取元素的方式

- 返回文档中拥有指定 ID 的**第一个**对象的引用
    ```js
    document.getElementById("id属性的值");
    ```
- 返回文档中符合条件的所有对象的引用
    ```js
    document.getElementsByTagName("标签名");
    document.getElementsByName("name属性的值"); 
    document.getElementsByClassName("class类样式的值");
    ```
- 返回文档中匹配指定 CSS 选择器的**第一个**元素
    ```js
    document.querySelector("标签名");
    document.querySelector("#id属性的值");
    document.querySelector(".class类样式的值");
    ```
- 返回文档中匹配指定 CSS 选择器的所有元素
    ```js
    document.querySelectorAll("标签名");
    document.querySelectorAll("#id属性的值");
    document.querySelectorAll(".class类样式的值");
    ```

### 注意: 以上方法获取的元素的集合都是伪数组

- 判断伪数组的方式是伪数组不能调用数组的方法。（Boolean(list.sort) == false）或者使用instanceof （list instanceof Array）。
    - **伪数组怎么变为真数组？**
    - 定义一个空数组，把伪数组的所有内容复制过去即可。

- `document.getElementById("xxx");` 返回值是一个标签对象，利用这个对象可以操作其中的元素，像 type，value 等都是它的元素。

- document.body 可以选中 body 标签。

- 注意: getElementsByClassName 在IE8等低版本浏览器不支持。
- `getElementsByName` 适用于表单标签，基本标签没有 name 属性
    - 基本标签: div,p,h1,ul,li,br等
    - 表单标签: input, select,option,form,textarea,datalist,label等

- 对样式的操作
    凡是 css 属性时由多个单词构成的，那么在 js 中设置的时候需要把 "-" 去掉，然后除第一个单词的首字母大写即可。
    比如: css里面的 background-color，在js里面的写法是 backgroundColor.

- 文本框注册失去焦点事件的时候使用 this.value.length === 0，而不使用 this.value === "请输入搜索内容" 是因为数字的比较比字符串的比较效率更高。

## 获取属性与内容

### 获取/设置成对标签中文本内容: 

    - `innerText` 属性是 IE8 标准属性，chrome，fireFox也支持。
    - `textContent` 是W3C标准属性,只有IE8不支持。
    - 在 IE8 下使用 textContent 获取成对标签中文本内容，返回值为 undefined。
        - 那么说明，浏览器不支持的属性的类型都为 undefined.
        - 通过判断元素有无 textContent 属性（没有则元素的 textContent 属性为 undefined）来决定用 innerText 还是 textContent。

### 获取元素内容
    - innerText 属性: 设置和获取只能得到文本内容(不包含tag)
    - innerHTML 属性: 不仅可以获得文本内容，还可以设置和获取 html 标签，让其显示或得到对应标签的格式。
    - innerHTML 和 innerText 是获取某个元素内部的内容，而outerHTML 和 outerText不仅获取某个元素内部的内容还包括这个元素本身内容。

### 自定义属性
    - 自定义属性在DOM里面不存在(强行获取得到undefined)
    - 设置也是一样的，通过 `DOM对象.属性` 设置的只是DOM对象的自定义属性，这个自定义属性不会在标签上显示出来。
    - **设置**: 通过`DOM对象.setAttibute("自定义属性的名字", "自定义属性的值")` 来设置自定义属性。
    - **获取**: 通过`DOM对象.getAttibute("自定义属性的名字")` 来获取自定义属性的值。
    - **移除**: 通过`DOM对象.removeAttibute("自定义属性的名字")` 来移除自定义属性。
    - PS: removeAttibute 也可以用来移除元素自带的属性，比如类 class 属性等。`removeAttribute("class")`

### 获取所有属性

    - 语法: `getComputedStyle(ele, null)`
    - 获取外部样式表的css属性: 



    ```js
    //IE中用currentStyle
    alert(document.getElementById("layer").currentStyle.width);
    alert(document.getElementById("layer").currentStyle.backgroundColor);

    //火狐和chrome用getComputedStyle
    let layer = document.getElementById("layer");
    let aClass = window.getComputedStyle(layer, null);
    alert(aClass["width"]);
    alert(aClass["backgroundColor"]);
    alert(aClass["height"]);

    //修改css属性是都可以使用style来设置。
    layer.style.width="200px";
    ```


## document
Document 接口表示任何在浏览器中载入的网页，并作为网页内容的入口，也就是 DOM 树

属性: 

```js
document.forms  // 返回对文档中所有 Form 对象引用。是数组类型
document.URL    //返回当前文档的 URL。 
document.body   // body元素
document.documentElement   // html元素(只读), 返回html dom中的root根节点 即<html>
```

方法: 

```js
document.getElementById() //返回对拥有指定 id 的第一个对象的引用。 
document.getElementsByName()// 返回带有指定名称的对象集合。 
document.getElementsByTagName() //返回带有指定标签名的对象集合。  
document.write() //向文档写 HTML 表达式 或 JavaScript 代码。
```

### offset

offsetWidth : 获取元素的宽（加边框）
offsetHeight: 获取元素的高（加边框）

offsetLeft  : 获取元素距离左边位置的值
offsetTop   : 获取元素距离上边位置的值

### scroll 

scroll: 卷曲

scrollWidth : 如果元素中内容宽度小于元素的宽度，则为元素的宽度（不含边框），否则为元素中内容的实际宽度
scrollHeight: 如果元素中内容高度小于元素的高度，则为元素的高度（不含边框），否则为元素中内容的实际高度
scrollLeft  : 元素中的内容往左卷曲出去的距离。（有滚动条的时候）
scrollTop   : 元素中的内容往上卷曲出去的距离。（有滚动条的时候）

获取页面实际的宽高
document.documentElement.scrollWidth || document.body.scrollWidth;
document.documentElement.scrollHeight || document.body.scrollHeight;

**封装获取 scrollLeft 和 scrollTop 的函数**

```javascript
function getScroll() {
    return {
            left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft,
            top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
    };
}
```

> 1、返回的是一个对象，这个对象有两个自定义属性 left 和 top ，使用的时候直接使用 getScroll().left 或者 getScroll().top 即可获得浏览器滚动条向左向上移动的距离。





## 节点

> 页面中的所有内容都可叫做节点, 包括标签,属性,文本(文字,空格,回车,换行等)
### 节点分类
    - 标签节点: 比如 div 标签，p 标签等。
    - 属性节点: 比如 class，value 等。
    - 文本节点: 比如闭合标签中的文本内容。

### 节点属性

    &nbsp;  | nodeType | nodeName | nodeValue
    --------|----------|----------|---------
    标签节点 | 1 | 大写的标签名字 | null
    属性节点 | 2 | 小写的属性名字 | 属性的值
    文本节点 | 3 | #text         | 文本内容

### 属性增删改查

```js
boxObj.attributes;          //返回元素所有属性集合对象
boxObj.attributes.length;   //返回属性节点个数
boxObj.attributes[0];       //返回第一个属性节点 （id="first"）
boxObj.attributes['id'];    //返回属性为 id 的节点

// 获取某个属性对应的值使用 getAttribute("属性的名称");
boxObj.getAttribute("id");  // first

// 修改或新增（如果不存在的话）属性的值
boxObj.setAttribute("id", "second"); // id="second"

// 移除属性
boxObj.removeAttribute("id");
```

注意: getAttribute的获取属性只能是行内样式才可以。

如 style 在行内样式可以使用 boxObj.style.color 获取到，如果是外部样式是获取不到的，但是设置可以。

外部样式获取使用 : window.getComputedStyle(boxObj)["color"]

但是 IE8 不支持。

**封装获取任意元素的任意一个属性值**

```js
function getStyle(element, attr) {
    return window.getComputedStyle ?
        window.getComputedStyle(element, null)[attr] :
        element.currentStyle[attr];
}
```

### 获取相关节点

1. 获取父节点/父元素
    - 父节点只能是标签，不能是属性节点和文本节点，所以父节点也是父元素。

    - parentNode: 获取元素的父节点

    - parentElement: 获取元素的父元素

2. 获取子节点和子元素

    - childNodes: 获取所有子节点（包括标签，属性，节点）

    - children: 获取所有子元素(仅包括标签)

3. 通过属性的名字获取属性节点

    - getAttributeNode: 可以获取属性节点

4. 获取节点和元素的12种方法
    ```js
    let ulObj = my$("uu");
    // 父节点
    console.log(ulObj.parentNode);
    // 父元素
    console.log(ulObj.parentElement);
    // 子节点
    console.log(ulObj.childNodes);
    // 子元素
    console.log(ulObj.children);
    // ------------------------------------------------
    // 第一个子节点
    console.log(ulObj.firstChild);
    // 第一个子元素
    console.log(ulObj.firstElementChild);
    // 最后一个子节点
    console.log(ulObj.lastChild);
    // 最后一个子元素
    console.log(ulObj.lastElementChild);
    // 某个元素的前一个兄弟节点
    console.log(my$("three").previousSibling);
    // 某个元素的前一个兄弟元素
    console.log(my$("three").previousElementSibling);
    // 某个元素的后一个兄弟节点
    console.log(my$("three").nextSibling);
    // 某个元素的后一个兄弟元素
    console.log(my$("three").nextElementSibling);
    ```
    1、以上前四个 IE8 都支持
    2、后面八个，IE8下，**所有获取节点的操作都获取的是元素，所有获取元素的操作都是 undefined。**


## 创建/添加元素

1. `document.write("标签代码及内容");`
    - 页面加载完毕后创建会替换掉所有内容(覆盖)
    - 在页面加载时使用则会保留原有的内容

2. `标签.innerHTML = "标签代码及内容";`
    - 不会影响原有的内容

3. 创建并添加节点
    ```js
    document.creatElement("标签的名字");//返回元素
    父元素.appendChild(创建的对象);     //在结尾添加

    ```

`appendChild(ele)`: 追加元素ele

`insertBefore(newEle, oldEle)`:  在oldEle元素前添加newEle

`removeChild(ele)`: 删除元素ele（或者子元素自杀 `ele.remove();`）
    - 旧版IE不支持remove

`replaceChild(newEle, oldEle)`: 将oldEle修改为newEle元素


## 事件

### 事件 event 

> 是发生并得到处理的操作，即: 事情来了，然后处理。
> - 事件名一般以单词on开头的
> - 鼠标,键盘事件onclick,窗口事件onload,表单事件onfocus...
> - 事件只有与 HTML 元素绑定之后才能被触发

### 事件对象 event object 

> 事件触发时, 浏览器自动创建对应的**event object**
- event object 是与特定事件相关的对象
- event object 包含有关该事件的详细信息(触发事件的元素、键盘鼠标的状态、位置等)
- event object 作为参数传递给事件处理函数
- event object 只在事件发生（如: 点击事件）的过程中才有效(只有有了事件之后才会有事件对象)
- event object 是自带的对象, 只需接收就好, 是固定写法, 写在事件函数的小括号里面，习惯写`e`

2. **event object**的属性(properties)

e.button    //返回当事件被触发时，哪个鼠标按钮被点击（鼠标左键，鼠标中键，鼠标右键）。 
e.altKey    //返回当事件被触发时，"ALT" 是否被按下，按下为 true。 
e.clientX   //返回当事件被触发时，鼠标指针的水平坐标（等同于 e.screenX）。 
e.pageX     // 返回鼠标距离页面左边的距离（包含滚动条滚动的距离 + 鼠标距左边可是区域的距离）

event.type      //事件的名称
event.bubbles   //事件是否为冒泡事件
event.target        //指向触发事件的元素
event.currentTarget //指向监听器直接绑定的元素

3. **event object**的方法(methods)

event.stopPropagation() //停止冒泡，阻止事件在 DOM 中继续冒泡
event.preventDefault()  //阻止事件的默认行为

### 事件传播(event propagation)机制

- 通过事件处理参数对象 `e.eventPhase` 属性可以查看当前事件所处的阶段
    1. 事件捕获:事件发生时, 先一路向下传递(`window->document->body->...`), 目标元素最后接受事件
    2. 事件目标: 实际目标接受事件
    3. 事件冒泡:事件从目标元素一路向上传递(`...->body->document->window`), 最后根元素接受事件
        - 事件冒泡: 当有多个元素嵌套，并且这些元素绑定了**相同的事件**，这时候如果里面的元素事件触发了，那么外面的事件会自动触发。


- addEventListener 绑定事件处理方法中第三个参数
    - 第三个参数是useCapture（变量）（用来判断是捕获还是冒泡）
    - 默认为false: 在冒泡阶段触发事件

- 阻止事件传递

5. js阻止事件冒泡和默认事件
w3c:e.stopPropagation
ie:window.event.cancelBubble = true
默认事件: 是指目标元素的默认行为比如a标签会跳转链接 form会提交表单
w3c:e.preventDefault()
ie:window.event.returnValue = false
另外js中的`return false`也可以阻止默认行为



### 事件处理程序 event handler

为了对事件作出响应，我们可以分配一个 处理程序(handler): 一个在事件发生时运行的函数
事件处理程序 名称是 "on"加事件名称，如onclick、onload.

为事件指定event handler的方法包括

1. **不建议 HTML事件处理程序**(HTML (inline) attribute)
    - 通过HTML元素的特性指定
    - `<input type="button" onclick="alert('Clicked')" />`

2. **DOM 0 级事件处理程序(DOM property)**
    - 通过 JS 指定事件处理程序的传统方式
    - 绑定: `元素.onclick = function(){};`
    - 解除: `元素.onclick = null;`
    - 同一个事件添加多个event handler会导致后一个覆盖前一个(属性)
    - 事件作用域: 程序中的 this 引用当前元素
        - (这时候的事件处理程序是在元素的作用域中运行)

3. **DOM 2 级事件处理程序**
    - 绑定: `元素.addEventListener(type, func, false);`
    - 解除: `元素.removeEventListener("click", f1, false);` 
    - 可以添加多个事件处理程序，多事件处理程序会按照添加它们的顺序触发
    - 注意:解除绑定不能使用匿名函数，因为需要同一个事件处理函数，而两个匿名函数是两个不同的函数，所以需要使用命名函数
    - 所有 DOM 节点中都包含这两个方法且接受 3 个参数
        1. 要处理的event名(不带on)
        2. 作为事件处理程序的函数
        3. useCapture(布尔值): 用来判断是捕获还是冒泡
            - 默认为false: 在冒泡阶段触发事件
    - 事件作用域: 程序中的 this 引用当前元素 
        - (与 DOM0 级方法一样，这里添加的事件处理程序也是在其依附的元素的作用域中运行)

4. **IE专用事件处理程序(非标)**

- 绑定: `元素.attachEvent("on"+type, func);`
- 解除: `元素.detachEvent("onclick", f1);` 
    - 参数1: 事件的类型（事件的名字），**要on**
    - 参数2: 事件处理函数（命名函数或者匿名函数）
- this 是 window (事件处理程序会在全局作用域中运行)
- 默认添加在在冒泡阶段
- 多个事件处理程序的执行顺序和DOM2相反，也就是和添加顺序相反

5. 绑定事件的区别addEventListener与attachEvent
    - 方法名不同；
    - 参数个数不同
    - 事件的类型有没有on
    - 浏览器支持不同
    - 事件中的 this 不同，addEventListener 中的 this 是当前绑定的对象；attachEvent 中的 this 是 window。


## cookie

cookie 就是一种特殊的字符串。是存放于指定网站的指定浏览器下面的文件夹下。用来帮助页面记录用户操作（会话跟踪技术）

cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。

cookie不支持本地文件，只能是网站下文件。

cookie 需要注意的属性有: 名称，内容，域名，路径，创建时间，到期时间。

### cookie 的创建与保存

```js
document.cookie = "名称=内容"

console.log(document.cookie); //取值，返回值为字符串(使用服务器模式打开网页才可以看到)
```
- 使用document对象的cookie属性，cookie是以键值对（key=value）字符串的方式保存在文件里的。
- 在cookie 里面，名称是唯一的标识
- 同一路径下，cookie的key是唯一的，但是不同路径下，key的值可以重复。

- 一次创建多个cookie，可以使用 “&”进行分割: 

- 在cookie 的名或值中不能有: 分号（;）、逗号（,）、等号（=）以及空格。
- 对于中文怎么办？
  1、中文编码 encodeURIComponent("中文") ，解码:  decodeURIComponent("%E4%B8%AD%E6%96%87")
  2、中文编码 escape("中文") ，解码: unescape("%u4E2D%u6587")
  3、中文编码 encodeURI("中文") ，解码: decodeURI("%E4%B8%AD%E6%96%87");


**cookie失效时间**

Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存（非持久）Cookie和硬盘（持久）Cookie。

- 内存Cookie由浏览器维护，保存在内存中，**浏览器**关闭后就消失了，其存在时间是短暂的。
- 硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。如果 cookie 包含到期日期，则可视为持久性 cookie。 在指定的到期日期，cookie 将从磁盘中删除。

如果设置的是一个过期的时间，会自动删除。

```js
// 设置cookie 到期时间
let date = new Date();
date.setDate(date.getDate()+7); // 设置7天后的时间点
document.cookie = "myage=18; expires=" + date; 	
```

### cookie应用

- 日期cookie(访问日期等)
- 保存用户登录状态(用户id等)
- 跟踪用户行为
- 定制页面(记录用户的选项)


- 封装函数实现cookie的增删改查


### cookie 的路径

同一路径(文件夹)下的网页及其子目录下的网页可以共享cookie，路径不同时，不能访问 。

如果想控制cookie可以访问的目录，需要使用path参数设置cookie，语法: 
```js
document.cookie="name=value; path=cookieDir"; 
```
- 其中cookieDir表示可访问cookie的目录
- 根目录`path=/`, 指定目录`path=/temp`

```js
例如: 
document.cookie="userId=007; path=/temp"; //就表示当前cookie仅能在temp目录下使用。 
document.cookie="userId=007; path=/";     //表示cookie在整个网站根目录下可用.
```
### cookie的域名

必须在绑定域名的服务器上才可以设置域名.

并且只能设置绑定的域名，也就是说，不同服务器间的cookie文件不共享。主机名是指同一个域下的不同主机。

例如: www.google.com 和 www.gmail.google.com 就是两个不同的主机名。

默认情况下，一个主机中创建的cookie在另一个主机下是不能被访问的，但可以通过 domain参数来实现对其的控制，其语法格式为:  `document.cookie="name=value; domain=cookieDomain";`

```js
// 以 google 为例，要实现跨主机访问，可以写为: 
document.cookie="name=value;domain=.google.com"; 
```
这样，所有google.com下的主机都可以访问该cookie。



# BOM


BOM,Browser Object Mode, 浏览器对象模型
在浏览器中的一些操作都可以使用 BOM 的方法进行编程处理
比如: 刷新浏览器、前进、后退、在地址栏输入 URL 等
BOM与DOM（文档对象模型）一起构成了Web API，提供了丰富的功能和接口，可以让开发者更好地控制和操作浏览器。但是需要注意的是，BOM的实现并不规范，不同的浏览器可能会有不同的实现，因此在编写代码时需要注意兼容性问题。

## BOM顶级对象window

window 是浏览器的顶级对象，当调用 window 下的属性和方法时，可以省略 window。

注意: 
- 拒绝 var, 只用 let const 来声明变量
    - var 声明的变量都是绑定到 window 身上
    - var 声明已有的变量，也不会报错
- 导致声明了一个变量并正确赋了值，实际上使用的却是浏览器内置的 window 属性
    - eg. var name -> window.name
    - eg. var top -> window.top (返回的是窗口层级最顶层窗口的引用，是个不可改写的属性)


## 获取属性

`window.getComputedStyle(element, string)`  返回值是这个元素所有属性的对象集合。
IE8: `元素.currentStyle`  的方式可以得到返回值为这个元素所有属性的集合

兼容代码：
```javascript
function getStyle(element, attr) {
    return window.getComputedStyle ?
        window.getComputedStyle(element, null)[attr] :
        element.currentStyle[attr];
}
```





## 系统对话框(模态窗口)
```js
// 不建议使用
window.alert();
window.prompt();
window.confirm(); // 两个按钮，分别返回 true 和 false
```
1. 暂停脚本的执行(页面的加载), 弹出 **模态窗口** 
2. 不允许用户与该页面的其余部分进行交互, 直到窗口被解除

- 模态窗 (model window)
  - “modal” 意味着用户不能与页面的其他部分 (例如点击其他按钮等) 进行交互, 直到他们处理完窗口

- 方法的两个**限制**: 模态窗口的 确切位置/确切外观 皆取决于浏览器, JS不能修改

## window对象&方法(可省略window)

>`<a href="javascript:window.location.reload()"></a>`
a 标签可以使用 javascript的方式来编写js代码。

### 打开/关闭窗口
- 打开窗口: window.open
```js
let windowObjectReference = window.open(strUrl, strWindowName, [strWindowFeatures]);

//            *strUrl === *要在新打开的窗口中加载的 URL
//     *strWindowName === *新窗口的名称
// *strWindowFeatures === *可选，列出新窗口的特征 (大小，位置，滚动条等) 作为一个DOMString
```
注: 如果两次弹出窗口名一样，将不会打开新弹窗，而再之前的弹窗中加载新页面。

- 关闭窗口: close()
```js
close(); // 关闭当前窗口
openId.close(); //关闭id为openId的窗口
```


### 页面加载顺序

为了避免在文档加载完成之前执行JS脚本可能出现的无法获取对象的情况

1. 将JS代码放置在网页底端

2. 通过window.onload来执行脚本代码

- window.onload 事件会在页面加载完毕（页面中所有内容、标签、属性以及外部引入的 js文件）时触发
事件处理函数绑定:
    - 方式一: window.οnlοad=function(){}
        - 不能多次绑定(后覆盖前), 多个函数需要一次性嵌套绑定完
    - 方式二: 使用addEventListener()和attachEvent()为onload事件绑定事件处理函数


- onunload: 页面关闭后才触发的事件
- onbeforeunload: 用于页面在刷新、关闭、跳转时提醒用户
    - 只要return返回不是null、undefined，就会触发默认行为，因此，可以在这里加入条件判断，优化用户体验。
    - alert、confirm对onbeforeunload无效

- onscroll : 当滚轮滚动时触发。
- onresize : 当窗口大小改变时触发。

### location对象

document和window对象中都有location属性
使用window对象下的location子对象来操作当前窗口的URL

注意 如果想要获得当前文档的完整url字符串(`'http://www.example.com/'`)，有四种方式
```js
document.location
document.location.href
document.URL
document.location.toString()
```
location对象属性
```js
window.location.href    // http://127.0.0.1:5500/CSS/CSS.html#btn
window.location.protocol// http:
window.location.hostname// 127.0.0.1
window.location.host    // 127.0.0.1:5500
window.location.port    // 5500
window.location.pathname// /CSS/CSS.html
window.location.hash    // #btn
window.location.search  // s或search之后的内容
```

location对象方法
```js
location.href = 'https://developer.mozilla.org/zh-CN/';
location.assign("https://developer.mozilla.org/zh-CN/");
//设置跳转的页面地址，以上两个属性和方法作用相同，并且都保存跳转前的地址（在浏览器中可以点击返回按钮）

location.reload();
//刷新页面。刷新页面也可以使用: 把href =自己本身的地址

location.replace("https://developer.mozilla.org/zh-CN/");
//设置跳转的页面地址，但是**不保存**跳转前的地址。
```

### history对象
history对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。
由于安全方面的考虑，开发人员无法得到用户浏览器的URL，但借由用户访问过的页面列表，可以在不知道实际URL的情况下实现后退和前进。
```js
window.history.length       // 返回浏览器历史列表中的 URL 数量
window.history.forward();   // 前进，加载 history 列表中的下一个 URL
window.history.back();      // 后退，加载 history 列表中的前一个 URL
window.history.go(num);     //加载 history 列表中的某个具体页面，或者要求浏览器移动到指定的页面数量（负数为后退number页，正数为前进number页）
```

## navigator 对象
navigator对象，用于提供当前浏览器及操作系统等信息
```js
window.navigator.platform; // 判断浏览器所在的系统平台 // win32
window.navigator.appName  // 浏览器名称 // Netscape
window.navigator.appVersion  // 浏览器版本 //5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36
window.navigator.userAgent; // 判断浏览器的类型，是谷歌火狐还是IE // chrome 下结果: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36
```

## screen 对象

screen 对象包含有关客户端显示屏幕的信息。
很少使用，用的话只在移动端使用，在PC端固定不变，获取的是设备的宽高，而不是页面的宽高。

```js
screen.availHeight  // 返回可用显示屏幕的高度 (除 Windows 任务栏之外)。 
screen.availWidth   //返回可用显示屏幕的宽度 (除 Windows 任务栏之外)。 
screen.height       //返回显示器屏幕的高度。 
screen.width        //返回显示器屏幕的宽度。
```

## iframe

引入外部链接，一般用于展示，可以一个页面放多个外部链接页面。如果操作页面的话，还是会跳转到外部链接网站。

```html
<iframe src="http://www.360.com" width="400px" height="400px"></iframe>
```



## 调度: setTimeout & setInterval

- 概念: 计划调用 scheduling a call: 等待特定的一段时间再执行函数
- 实现: `setTimeout` `setInterval`
- 注意: 以上方法不在 JS 规范中(浏览器与Node.js都支持)

### setTimeout

``` javascript {line-numbers}
let timerId = setTimeout(func, [delay], [arg1], [arg2], ...);
clearTimeout(timerId);
```

- 参数

  - `timerId`: 调用 `setTimeout` 会返回一个 定时器标识符 timer identifier
    - 可使用 `clearTimeout` 取消调度
    - 浏览器中的 定时器标识符 是数字

  - `func`: 要推迟的函数
    - 可传入箭头函数
    - 不建议: 也可传入代码字符串

  - `delay`: 延时长度, 单位毫秒, 默认为 `0`

  - `arg1, arg2`: 传入推迟函数的参数列表

- 嵌套使用 setTimeout 实现周期性调度

  ``` javascript {.line-numbers}
  let timerId = setTimeout(function loop() {
  ……
  if (something happen) {delay *= 2} //依据情况改变间隔
  timerId = setTimeout(loop, delay);
  }, delay);
  ```

  1. 比 setInterval 更加灵活(依据结果调整下一次调度)
  2. 相较于 setInterval 能更精确地设置两次执行之间的延时

  - 使用 setInterval 时, 函数**执行耗时**占用间隔时间

- 垃圾回收

  - 当一个函数传入 `setInterval/setTimeout` 时会为其创建内部引用
  - 在 `setTimeout` 调用函数前 (`clearInterval` 被调用前) 函数在内存中
    - 函数引用的外部变量也会一直存在
    - 不需要时及时取消调度函数

- 零延时 setTimeout

  - 只有在当前脚本**执行完后**, 调度程序才会调用 `func`
  - 设置 `delay` 为 `0` 或不设置 `delay`
  - 让 `func` 在当前脚本执行完后立即执行
  - 非实际零延时: 经过 5 重嵌套定时器之后的时间间隔被强制设定为至少 4 毫秒



### setInterval

``` javascript {line-numbers}
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);
clearInterval(timerId);
```

- 方法与 setTimeout 相同
- `setInterval` 每间隔给定的时间周期性执行
- 阻止后续调用使用 `clearInterval(timerId)`



### 变速动画

```js
// 变速动画移动函数
function animation(element, target) {
  clearInterval(element.timeId); // 每次调用函数就清理之前的timeId
  // 判断当前的位置
  element.timeId = setInterval(function () {
    var current = element.offsetLeft; // 不能使用 element.style.left
    var onestep = (target - current) / 10;
    onestep = onestep > 0 ? Math.ceil(onestep) : Math.floor(onestep);
    current += onestep;
    element.style.left = current + "px";
    // if (Math.abs(current - target) >= onestep) {
    //     element.style.left = current + "px";
    // } else {
    //     clearInterval(timeId);
    //     element.style.left = target + "px";
    // }

    if(target === current) {
      clearInterval(element.timeId);
      return;
    }

    // 测试代码
    console.log("target="+target+", current="+current+", step="+onestep);
  }, 20);
}
```


# JS高级

>构造函数，实例对象，原型对象三者的关系
1、实例对象是由构造函数创建的；
2、构造函数中有个属性prototype，指向原型对象；
3、原型对象中有一个构造器，指向构造函数；
4、实例对象中的下划线原型对象__proto__ 指向原型对象 prototype。
5、原型对象中的方法可以被实例对象访问，虽然实例对象中没有这个方法，但是实例对象中 __proto__ 指向  prototype，所以所有的实例对象共享原型对象中的方法。


## 面向对象编程

面向对象编程（Object Oriented Programming，OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。

JavaScript 语言的对象体系基于构造函数（constructor）和原型链（prototype）而不是基于“类”的

JavaScript 中几乎所有的对象都是 Object 类型的实例，它们都会从 Object.prototype 继承属性和方法

JavaScript 语言使用构造函数（constructor）作为对象的模板。


## 例子

```js
function Cats() {}
let cat = new Cats();

Object.getPrototypeOf(cat) === Cats.prototype;
cat.__proto__ === Cats.prototype;
console.log(Cats.prototype); // { constructor: Cats } (隐藏属性 [[Prototype]]: Object)

// Object.getPrototypeOf(Cats) !== Object.prototype; (Cats作为函数没有__proto__属性)
Cats.prototype.__proto__ === Object.prototype;
console.log(Object.prototype) // { constructor: Object ... }

Object.prototype.__proto__ === null;
```


## 构造函数

> 构造函数专门用来生成实例对象, 是其模板, 基本结构
- 构造函数结构及使用
    - 首字母大写
    - 使用new命令生成一个实例对象
        - 若未使用new命令调用则
            1. 构造函数就变成了普通函数, 并不会生成实例对象(undefined)
            2. this这时代表**全局对象**
            - 解决: 1. 构造函数内部使用严格模式; 2. 内部判断是否使用new命令
        - 执行过程: 
            1. new命令会执行构造函数
            2. 创建一个新的空对象作为将要返回的对象实例
            3. 空对象的原型指向构造函数的prototype属性
            4. 空对象赋值给函数内部的this关键字
            
    - 包含常规属性prototype, 指向原型对象
        - 原型对象中有一个构造器, 指向构造函数



### new命令原理

使用new命令时

1. 创建一个新的空对象，作为将要返回的对象实例
2. 将这个空对象的原型，指向构造函数的prototype属性
3. 将这个空对象赋值给函数内部的this关键字
4. 开始执行构造函数内部的代码
5. 如果构造函数内部有`return 某个obj`语句则返回这个指定的对象
6. 否则忽略return, 直接返回this对象

自己动手实现一个 new 你就知道 对象和实例的关系
```js
function myNew (fun) {
  return function () {
    // 创建一个新对象且将其隐式原型指向构造函数原型
    let obj = {
      __proto__ : fun.prototype
    }
    // 执行构造函数
    fun.call(obj, ...arguments)
    // 返回该对象
    return obj
  }
}

function person(name, age) {
  this.name = name
  this.age = age
}
let obj = myNew(person)('chen', 18) 
```


## `[[prototype]]` 和 `prototype` 


### `prototype`
* **每个**函数都有一个名为 "prototype" 的常规属性 **(以构造函数F为例)**
* F.prototype 的值要么是一个对象，要么就是 null
* F.prototype 仅在 new F 被调用时使用
    * 如果 F.prototype 是一个对象，那么 new 操作符会使用它为新对象设置 `[[Prototype]]`(原型继承)
* F.prototype = {constructor：F} 为默认值
* F.prototype中**包含**隐藏属性`[[prototype]]`指向原型


### `[[prototype]]`
* JS中的对象都有一个特殊的隐藏属性`[[prototype]]`
* `someObject.[[Prototype]]` 符号是用于指向 someObject 的原型
* `[[Prototype]]` 可以通过 Object.getPrototypeOf(someObject) 和 Object.setPrototypeOf(someObject) 访问器来访问/设置
* 以上2个方法等同于属性 `someObject.__proto__`
    * `__proto__`是非标准但许多浏览器实现的属性
    - `__proto__` **设置或读取**原型被认为已经过时且不推荐使用
    - `__proto__` 不被反对的唯一的用法是在创建新对象时，将其用作属性：`{ __proto__: ... }`
- 特殊的方法：`Object.create(proto, [descriptors])` —— 利用给定的 proto 作为 `[[Prototype]]` 和可选的属性描述来创建一个空对象。可选的第二参数：属性描述器。


## 原型

在 JavaScript 中，所有的对象都有一个隐藏的 `[[Prototype]]` 属性，它要么是另一个对象，要么就是 null

通过 `[[Prototype]]` 引用的对象被称为“原型”。

我们可以使用 `obj.__proto__` 访问它（历史遗留下来的 getter/setter，

如果我们想要读取 obj 的一个属性或者调用一个方法，并且它不存在，那么 JavaScript 就会尝试在原型中查找它。

写/删除操作直接在对象上进行，它们不使用原型（假设它是数据属性，不是 setter）。

属性查找和执行是两回事儿。

如果我们调用 obj.method()，而且 method 是从原型中获取的，this 仍然会引用 obj。因此，方法始终与当前对象一起使用，即使方法是继承的。

无论在哪里找到方法：在一个对象还是在原型中。在一个方法调用中，**this 始终是点符号 `.` 前面的对象**。

for..in 循环在其**自身和继承**的属性上进行迭代。

所有其他的键/值获取方法仅对对象本身起作用。

如果速度很重要，就请不要修改已存在的对象的 `[[Prototype]]`
从技术上来讲，我们可以在任何时候 get/set `[[Prototype]]`。但是通常我们只在创建对象的时候设置它一次，自那之后不再修改：rabbit 继承自 animal，之后不再更改。

并且，JavaScript 引擎对此进行了高度优化。用 `Object.setPrototypeOf` 或 `obj.__proto__`= “即时”更改原型是一个非常缓慢的操作，因为它破坏了对象属性访问操作的内部优化。因此，除非你知道自己在做什么，或者 JavaScript 的执行速度对你来说完全不重要，否则请避免使用它。



### 原生的原型 Object.prototype

`obj = {}` 和 `obj = new Object()` 是一个意思，其中 Object 就是一个内建的对象构造函数，其自身的 prototype 指向一个带有 toString 和其他方法的一个巨大的对象。

其他内建对象，像 Array、Date、Function 及其他，都在 prototype 上挂载了方法。

按照规范，所有的内建原型顶端都是 Object.prototype
```js
per.__proto__ === Person.prototype
Person.prototype.__proto__ === Object.prototype
Object.prototype.__proto__ === null;
```

### 基本数据类型

所有的内建对象都遵循相同的模式（pattern）：
方法都存储在 prototype 中（Array.prototype、Object.prototype、Date.prototype 等）。
对象本身只存储数据（数组元素、对象属性、日期）。

字符串、数字和布尔值不是对象。
如果我们试图访问它们的属性，那么临时包装器对象将会通过内建的构造器 String、Number 和 Boolean 被创建。它们提供给我们操作字符串、数字和布尔值的方法然后消失

值 null 和 undefined 没有对象包装器
特殊值 null 和 undefined 比较特殊。它们没有对象包装器，所以它们没有方法和属性。并且它们也没有相应的原型。

在现代编程中，只有一种情况下允许修改原生原型。那就是 polyfilling


## 原型的方法

1. `obj.hasOwnProperty(prop)`: 返回一个布尔值，指示对象自身属性中是否具有指定的属性

2. `prototypeObj.isPrototypeOf(object)`: 用于测试一个对象(prototypeObj)是否存在于另一个对象(object)的原型链上

3. `obj.propertyIsEnumerable(prop)`: 返回一个布尔值，表示指定的属性是否可枚举
    - 可枚举： 如果一个属性可以使用for in遍历出，就是可枚举的。
        1. 这个属性必须属于实例的，并且不属于原型。
        2. 这个属性必须是可枚举的，也就是自定义的属性。
        3. 如果对象没有指定的属性，该方法返回false
        4. 如果符合1和2两个要求，就会返回true.

4. constructor: 返回创建实例对象的 Object 构造函数的引用。(可以通过调用对象的constructor重新执行对象的构造函数。)

将Box.prototype.constructor设置为Box，以确保每个实例对象都是通过Box构造函数创建的。


var o = {};
o.constructor === Object; // true

var o = new Object;
o.constructor === Object; // true

var a = [];
a.constructor === Array; // true

var a = new Array;
a.constructor === Array // true

var n = new Number(3);
n.constructor === Number; // true


## call和apply和bind

### call和apply

装饰器（decorator）：一个特殊的函数，它接受另一个函数并改变它的行为。

call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。

call 和 apply二者的作用完全一样，只是接受参数的方式不太一样

**`Function.apply(obj,args)`**
1. ` obj`: 这个对象将代替Function类里this对象
2. `args`: 这个是数组或类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。

- 在非严格模式下当我们第一个参数传递为null或undefined时，函数体内的this会指向默认的宿主对象，在浏览器中则是window


**`function.call(thisArg, arg1, arg2, ...)`**
- call方法与apply方法的第一个参数是一样的，只不过第二个参数是一个参数列表

Person.call(this, name, age);第一个参数 this，表示当前对象，意思是当前对象呼叫 Person，将 name 和 age 传过来，具体传多少，我自己指定。这样不同的子类，通过自己可以设置不同的属性。


```javascript
foo.call(传入的对象,参数1，参数2, ...);
foo.apply(传入的对象,[参数1，参数2, ...]);
```
apple 和 call 都可以改变调用其的函数或方法中的 this 指向。this的指向为传入的对象。

当传入对象的位置为 null 时，不改变this的执行，此时相当于函数的一般执行。

### bind

**`fn.bind(obj)();`**

call，apply和bind的区别：

1、call,apply 一调用函数就执行了，直接改变调用函数的this指向，然后执行。
2、而bind的调用函数并没有直接执行。bind并不会改变调用它的this的指向，它的返回值是和调用它的函数本身，只是改变了this的指向。





### 组合继承（原型方式继承 + 借用构造函数继承）


## getters与setters

`get`关键字用于创建一个getter函数, 将对象属性绑定到查询该属性时将被调用的函数
- 访问该属性时才会调用函数计算
- getter函数无任何参数
- 不能重名(数据属性或另一个getter)
- 可以删除getter
```js
{get prop() { /* … */ } }
{get [expression]() { /* … */ } }

delete obj.prop
```

set关键字用于创建一个setter函数, 当尝试设置属性时会调用。它还可以在类class中应用。
- 有且只有一个参数
- 不能重名(数据属性或另一个setter)
- getter和setter可以有相同的名字
- 可以删除setter
```js
{ set prop(val) { /* … */ } }
{ set [expression](val) { /* … */ } }

delete obj.prop
```

### 在类中使用getter和setter

## 闭包

闭包是指有权访问另一个函数作用域中变量的函数

当一个函数的返回值是另外一个函数,而返回的那个函数如果调用了其父函数内部的变量,且返回的这个函数在外部被执行就产生了闭包。

要求：

- 必须有两个函数，并且是嵌套关系，外面的函数必须返回里面的函数。
- 在全局中必须接收返回函数作为变量存储.

### 闭包的模式

1. 函数模式的闭包：函数中包含函数。
    
    ```js
    function fn1() {
        var i=0;
        return function () {
            i++;
            console.log(i);
        }
    }
    // fn1的返回值是一个函数，函数也是对象，存在堆中。那么与此函数相关的内容，也会被存放在堆中。就不容易被清除。
    var fn2=fn1(); 
    fn2(); // 1
    fn2(); // 2
    fn2(); // 3
    ```

2. 对象模式的闭包：函数中包含对象。

    ```js
    var method=(function () {
        var i=0;
        return {
            a:1,
            b:2,
            c:function () {
                i++;
                console.log(i);
            }
        }
    })();
    method.c(); // 1
    method.c(); // 2
    method.c(); // 3
    ```

3. 面向对象方式的闭包：

    ```js
    var Box=(function () {
        function Box() {

        }
        Box.prototype={

        };
        return Box;
    })()
    ```

### 闭包的特点

- 函数嵌套函数
- 函数内部可以引用外部的参数和变量
- 参数和变量不会被垃圾回收机制回收
    - 也是缓存的数据，导致在闭包的范围内一直起作用，造成内存泄漏，不会被垃圾回收

### 闭包的应用

缓存数据，函数中的数据，外面可以使用。

### 沙箱

一小块的真实环境，里面发生的事情不会影响到外面。相同的操作，相同的数据都不会和外面发生冲突。

作用：避免命名冲突。

比如：**自调用函数**里面就相当于一个沙箱环境。

```js
(function (){
        
}());
```


## class类

基本语法是：
```js
class User {
  constructor(name) { // new 会自动调用 constructor() 方法
    this.name = name; // 初始化对象... 
  } 
  method1() { } // 新对象具有所有方法
  method2() { } // 方法之间不用逗号
  sayHi() { alert(this.name); }
}

let user = new User("John");
user.sayHi();

typeof User === 'function';
User === User.prototype.constructor;
```
`class User {...}`创建函数`User`, 该函数成为类声明的结果
该函数的代码来自`constructor`方法(无该方法则为空)
储存类中的方法

`new User`被创建后, 调用其方法会从原型中获取

### class不仅仅是语法糖

1. 通过 class 创建的函数具有特殊的内部属性标记 `[[IsClassConstructor]]: true`
    - 必须用new声明, 直接调用报错
    - 大多数 JS 引擎中的类构造器的字符串表示形式都以 “class…” 开头
2. 类方法不可枚举
    - 默认所有方法 `enumerable: false;`
    - for..in 调用时class方法不会出现\
3. 类总是使用 `use strict`
    - 类构造中的所有代码都将自动进入严格模式

### 类表达式

就像函数一样，类可以在另外一个表达式中被定义，被传递，被返回，被赋值等。

类似于命名函数表达式NFE, 类表达式也可以有名字且
    1、它允许类在内部引用自己。
    2、它在类的外部是不可见的。



作为一个经验丰富的前端程序员, 你需要向初学者详细地解释以下JS代码的作用及原理, 着重指出最后的结果是如何产生的, 最后总结代码所运用的知识点:
```
(function (win) {
    function Box() {}
    Box.prototype = {}
    Box.prototype.constructor = Box;
    win.Box = Box;
})(window);

var box = new Box();
console.log(box);
```

你需要向初学者详细地解释以下JS代码中的各个`  `的作用






























# 一、流程控制

## switch

> **switch底层用的是 === 比较。**

参考链接: http://www.cnblogs.com/codetker/p/4680996.html

```javascript
switch ("111"){
    case 111:
        alert(111);
        break;
    case 222:
        alert(222);
        break;
    case 222:
        alert(333);
        break;
    default :
        alert("都不是！");
        break;
}
```

当在循环中添加事件的时候，建议不使用匿名函数，因为每个匿名函数都会占用一片内存空间，而使用函数调用的方式，不管循环多少次，都使用一份代码。
tableObj.border = "1"; 不能使用 tableObj.style.border = "1px solid red"; 这样的话，只有table有边框，而 tr 没边框。所以 js 中，table 标签有自带的 border 属性可以设置边框，注意不需要 px。